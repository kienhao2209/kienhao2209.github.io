[
{
	"uri": "/",
	"title": "Building an AI Invoice Scanning System on a Serverless Architecture",
	"tags": [],
	"description": "",
	"content": "Building an AI Invoice Scanning System on a Serverless Architecture Overview In this lab, you will build an AI-powered invoice scanning system using a Serverless architecture on AWS. The application allows users to upload invoices, extract data using Amazon Textract, analyze and normalize the data with Amazon Bedrock, store it in Amazon DynamoDB, and access it through API Gateway.\nThe frontend is deployed on AWS Amplify, supporting authentication and authorization with Amazon Cognito. The system is monitored using CloudWatch.\nAmazon S3 Amazon S3 (Simple Storage Service) is AWS’s object storage service used to store invoice files and related documents. It ensures high data durability, flexible scalability, and fast access from anywhere.\nAmazon Textract Amazon Textract is an AI service for extracting text, tables, and structured data from invoices. Textract eliminates manual data entry and speeds up the digitization process.\nAmazon Bedrock Amazon Bedrock is a serverless AI model service used to analyze, interpret, and normalize invoice data. It enables advanced information processing without managing AI infrastructure.\nAWS Lambda AWS Lambda is a serverless computing service that runs code to handle events such as invoice uploads, data extraction, and storage without the need to manage servers.\nAmazon DynamoDB Amazon DynamoDB is a fully managed NoSQL database used to store invoice data after it has been extracted and analyzed. DynamoDB offers fast performance, automatic scaling, and high reliability.\nAmazon API Gateway Amazon API Gateway is a service for creating, managing, and securing APIs. In this system, it provides APIs for uploading invoice files and retrieving stored data.\nAmazon Cognito Amazon Cognito is a user authentication and authorization service. It provides secure sign-in for the frontend application and integrates seamlessly with API Gateway and other AWS services.\nAWS Amplify AWS Amplify is a frontend development and deployment platform that helps build modern user interfaces and connect directly to backend APIs. The application’s frontend is deployed using Amplify.\nAmazon CloudWatch Amazon CloudWatch is a monitoring service that collects and analyzes logs, metrics, and events from all system components. It helps monitor performance and provides early alerts for potential issues.\nContent Introduction Environment Setup AI-Powered Invoice Processing Deploying API Gateway Test with Postman Deploying Frontend End-to-End Hands-on Resource Cleanup "
},
{
	"uri": "/7-cleanup/7.1-removeapigateway/",
	"title": "Delete API Gateway",
	"tags": [],
	"description": "",
	"content": "Steps to follow Open AWS Management Console → Search for API Gateway service. In the API list, select PostInvoiceAPI. In the API actions menu, choose Delete API. Confirm by entering: confirm. API test deleted successfully. Repeat the same steps for GetInvoiceAPI. "
},
{
	"uri": "/4-deployingapigateway/4.1-creategetapigateway/",
	"title": "Create API Gateway (GET)",
	"tags": [],
	"description": "",
	"content": "Tổng quan This section guides you through creating a REST API named GetInvoiceAPI with routes for querying and updating invoice data. Each route is connected to a Lambda function and has CORS enabled, then deployed with a dev stage.\nStep 1: Create REST API Sign in to the AWS Management Console, search for and open API Gateway. Click Create an API. Select REST API, then click Build. Configure the following:\nAPI name: GetInvoiceAPI Description: Post Invoice File by API Gateway Endpoint Type: Select Regional. Click Create API to finish. Step 2: Create Resources \u0026amp; Methods Resource: /invoice In GetInvoiceAPI, choose Create resource. Enter:\nResource path: / Resource name: invoice Click Create resource.\nAfter creating /invoice, select it in the resource tree. Click Create method. Configure in Create method:\nMethod type: GET. Integration type: Lambda function. Lambda proxy integration: Enabled. Lambda function: FetchInvoiceDetailsFunction. Click Create method. The API Gateway will be created and redirected to the API Gateway details configuration page. Resource: /invoice/{id} In the resource tree, select the /invoice resource. In the resource tree, select the /invoice resource. Enter the following:\nResource path: /invoice/ Resource name: {id} Click Create resource.\nAfter the /invoice/{id} resource is created, select it again in the resource tree. Click Create method. Configure the Create method section:\nMethod type: GET. Integration type: Lambda function. Lambda proxy integration: Enabled. Lambda function: FetchInvoiceDetailsFunction. Click Create method. Proceed to add a PATCH method.\nSelect the resource in the tree and click Create method again. - Configure similarly:\r- **Method type**: PATCH\r- **Integration type**: Lambda Function\r- **Use Lambda Proxy integration**: Enabled\r- **Lambda Function**: FetchInvoiceDetailsFunction\rClick Create method. Resource: /invoice/starred In the GetInvoiceAPI, select the /invoice resource. Click Create resource. Configure:\nResource path: /invoice/ Resource name: starred Click Create resource.\nAfter the resource is created, select /invoice/starred in the tree. Click Create method. Configure the Create method:\nMethod type: GET. Integration type: Lambda function. Lambda proxy integration: Enabled. Lambda function: FetchInvoiceDetailsFunction. Click Create method. Resource: /invoice/starred/{id} In GetInvoiceAPI, select /invoice/starred. Click Create resource. Configure:\nResource path: /invoice/starred/ Resource name: {id} Click Create resource.\nAfter the resource is created, select /invoice/starred/{id}. Click Create method. Configure the Create method:\nMethod type: PATCH. Integration type: Lambda function. Lambda proxy integration: Enabled. Lambda function: FetchInvoiceDetailsFunction. Click Create method. Resource: /invoice/tags In GetInvoiceAPI, select /invoice. Click Create resource. Configure:\nResource path: /invoice/ Resource name: tags Click Create resource.\nResource: /invoice/tags/{id} In the resource tree, select /invoice/tags. Click Create resource. Configure:\nResource path: /invoice/tags/ Resource name: {id} Click Create resource.\nAfter the resource is created, select /invoice/tags/{id}. Click Create method. Configure the Create method:\nMethod type: PATCH. Integration type: Lambda function. Lambda proxy integration: Enabled. Lambda function: FetchInvoiceDetailsFunction. Click Create method. Step 3: Enable CORS for methods In the resource tree of GetInvoiceAPI, select /invoice/{id}. Click Enable CORS. In Access-Control-Allow-Methods, Enabled CORS:\nGET PATCH Click Save.\nRepeat the above steps for the following resources:\n/invoice/starred/{id}: Enabled CORS for PATCH /invoice/tags/{id}: Enabled CORS for PATCH Step 4: Deploy API Click Deploy API. In the Deploy API modal:\nStage: [New Stage]. Stage name: dev. Deployment description: Test API Method GET. Click Deploy. "
},
{
	"uri": "/2-environmentsetup/2.1-createpolicy/",
	"title": "Create IAM Policies",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will create 2 essential IAM Policies for the system:\nAIInvoiceScannerFullPolicy: grants full permissions to backend services such as Textract, Bedrock, Lambda, DynamoDB, API Gateway, Cognito, and CloudWatch. AmplifyAdminPolicy: grants full access for frontend deployment using AWS Amplify. Step 1: Access IAM Console Go to AWS Console, search for IAM, then select IAM from the results. In the left-hand menu, click on Policies. Click the Create policy button. Step 2: Create the AIInvoiceScannerFullPolicy On the Create Policy page, switch to the JSON tab. Paste the following code into the editor: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;S3FullAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;TextractFullAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;textract:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;BedrockFullAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;bedrock:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;LambdaFullAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;lambda:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;LambdaBasicExecutionRole\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;DynamoDBFullAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;dynamodb:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;APIGatewayAdmin\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;apigateway:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;CognitoPowerUser\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;cognito-idp:*\u0026#34;, \u0026#34;cognito-sync:*\u0026#34;, \u0026#34;cognito-identity:*\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;CloudWatchFullAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;cloudwatch:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowIAMAccessForLambdaSetup\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;iam:DetachRolePolicy\u0026#34;, \u0026#34;iam:GetPolicy\u0026#34;, \u0026#34;iam:GetPolicyVersion\u0026#34;, \u0026#34;iam:GetRole\u0026#34;, \u0026#34;iam:ListRoles\u0026#34;, \u0026#34;iam:PassRole\u0026#34;, \u0026#34;iam:ListPolicies\u0026#34;, \u0026#34;iam:AttachRolePolicy\u0026#34;, \u0026#34;iam:ListRolePolicies\u0026#34;, \u0026#34;iam:ListAttachedRolePolicies\u0026#34;, \u0026#34;iam:PutRolePolicy\u0026#34;, \u0026#34;iam:GetRolePolicy\u0026#34;, \u0026#34;iam:ListInstanceProfilesForRole\u0026#34;, \u0026#34;iam:RemoveRoleFromInstanceProfile\u0026#34;, \u0026#34;iam:DeleteRole\u0026#34;, \u0026#34;iam:DeleteRolePolicy\u0026#34;, \u0026#34;iam:CreateRole\u0026#34;, \u0026#34;iam:TagRole\u0026#34;, \u0026#34;iam:UpdateRole\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowValidatePolicy\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;access-analyzer:ValidatePolicy\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;CloudWatchLogsFullAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:DescribeLogGroups\u0026#34;, \u0026#34;logs:DescribeLogStreams\u0026#34;, \u0026#34;logs:GetLogEvents\u0026#34;, \u0026#34;logs:FilterLogEvents\u0026#34;, \u0026#34;logs:DeleteLogGroup\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowDynamoDBAutoScalingDescribe\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;application-autoscaling:DescribeScalableTargets\u0026#34;, \u0026#34;application-autoscaling:DescribeScalingPolicies\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AllowEC2VpcEndpointDescribe\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;ec2:DescribeVpcEndpoints\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Click Next to proceed. Fill in the policy details:\nPolicy name: AIInvoiceScannerFullPolicy Description: Full permissions for S3, Textract, Bedrock, Lambda, DynamoDB, API Gateway, Cognito, and CloudWatch Click Create policy to complete. Step 3: Create the AmplifyAdminPolicy Return to the Policies list, click Create policy. Switch to the JSON tab and paste the following content:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;AmplifyAdminAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;amplify:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;AmplifyHostingAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;amplifybackend:*\u0026#34;, \u0026#34;amplifyuibuilder:*\u0026#34;], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Click Next. Enter the policy details:\nPolicy name: AmplifyAdminPolicy Description: Full access for Amplify frontend and backend Click Create policy. Step 4: Review the policies Go back to the Policies list.\nSearch for and verify the two created policies:\nAIInvoiceScannerFullPolicy AmplifyAdminPolicy If you don’t see the newly created policies, try refreshing your browser or double-check the names.\n"
},
{
	"uri": "/3-aipoweredinvoiceprocessing/3.1-createlambdarole/",
	"title": "Create IAM Role for Lambda",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will create a dedicated IAM Role so that Lambda functions in the Serverless Invoice Scanner system can access AWS services such as Amazon Textract, Amazon Bedrock, Amazon DynamoDB, Amazon S3, and CloudWatch Logs.\nStep 1: Access the IAM Console Open the AWS Management Console in Incognito mode to avoid session conflicts if you\u0026rsquo;re logged in with multiple accounts.\nSearch for and select IAM in the search bar.\nIn the left navigation pane, choose Roles, then click Create role. Step 2: Configure Role for Lambda Trusted entity type: select AWS service Use case: select Lambda Click Next to proceed. Step 3: Attach Permissions to the IAM Role In the Add permissions step, search for and check the following policies:\nAmazonS3FullAccess AmazonDynamoDBFullAccess AmazonTextractFullAccess AmazonBedrockFullAccess AWSLambdaBasicExecutionRole Click Next to continue. Step 4: Name and Finish Role name: LambdaExecutionRole-AIInvoiceScanner Description: Role for Lambda to access S3, Textract, Bedrock, DynamoDB, and CloudWatch Click Create role to finish. After creation, go to the Roles section in the IAM Console. You will see the LambdaExecutionRole-AIInvoiceScanner listed. "
},
{
	"uri": "/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction In this lab, you’ll build a Serverless AI Invoice Scanner using AWS services. The solution consists of the following core components:\nAmazon S3 – to store uploaded invoice files. AWS Lambda – to process invoices, orchestrating Amazon Textract and Bedrock. Amazon DynamoDB – to store the extracted and normalized data. Amazon API Gateway – to expose secure APIs for uploading and retrieving invoice data. AWS Amplify – to host and manage the frontend application. Amazon Cognito – to handle user authentication and control API access. Amazon CloudWatch – to monitor logs, metrics, and overall system health. Learning Objectives By completing this lab, you’ll gain hands-on experience in:\nDesigning and building a serverless AI-driven architecture. Using Amazon Textract and Bedrock to extract and enrich invoice data. Creating secure, scalable APIs with API Gateway, Lambda, and DynamoDB. Deploying a modern frontend with AWS Amplify and securing it with Cognito. Monitoring performance, optimizing costs, and cleaning up AWS resources. "
},
{
	"uri": "/5-testwithpostman/5.1-testuploadfile/",
	"title": "Testing Invoice File Upload",
	"tags": [],
	"description": "",
	"content": "Prerequisites Postman installed (https://www.postman.com/downloads). Resource Preparation Download the following files before testing the API in Postman:\ndemo_invoice.png demo_invoice2.png demo_invoice3.png Step 1: Convert Images to Base64 We will use the online tool base64-image.de:\nVisit the website and select the file demo_invoice.png. The website will automatically convert it to Base64. Click \u0026lt;/\u0026gt; show code to retrieve the Base64 string. Copy the Base64 code. Save it temporarily in Notepad.\nRepeat the process for the remaining two files.\nStep 2: Create a Postman Collection Open the Postman application. Click the \u0026quot;+\u0026quot; button to create a new collection. Select Blank Collection. Name it: InvoiceUploadAPI-Tests Step 3: Create a Request Inside the newly created collection, click the \u0026quot;+\u0026quot; button to add a request. Name the request: Upload Invoice. Select the POST method. Go to API Gateway, select the API: PostInvoiceAPI. Navigate to the Stages section. Click the “+” button to reveal the full URL. Select the POST method and copy the Invoke URL. Paste the Invoke URL into Postman as shown: Go to the Headers tab and configure as follows: Content-Type: application/json Navigate to the Body tab → Select raw → Choose JSON. Paste the following JSON into Postman: { \u0026#34;file\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;\u0026#34; } Paste the Base64 string saved earlier in Notepad and specify the filename as follows: Click the Send button to view the results. A successful response will appear as follows: Go to S3 → Navigate to the uploads/ folder → Verify the uploaded file. Access DynamoDB → Select Explore items → Choose the InvoiceData table. "
},
{
	"uri": "/7-cleanup/7.2-removelambdafunction/",
	"title": "Delete Lambda Functions",
	"tags": [],
	"description": "",
	"content": "Steps to follow Open AWS Management Console → Search for Lambda service. In the Lambda list, select the following Lambdas: In the Actions section, select Delete. Confirm by entering: confirm. Check Lambda deleted successfully. "
},
{
	"uri": "/4-deployingapigateway/4.2-createpostapigateway/",
	"title": "Create API Gateway (POST)",
	"tags": [],
	"description": "",
	"content": "Tổng quan In this section, you will create a REST API Gateway to receive invoices uploaded by users through the POST /uploads endpoint. This API will integrate with Lambda Function #1 UploadInvoiceFileFunction, automatically process invoice images/files using AI, and store the results into DynamoDB.\nStep 1: Create a REST API Log in to the AWS Management Console, find and access API Gateway. Click Create API. Choose REST API type, then click Build. In the configuration section:\nAPI name: PostInvoiceAPI Description: Post Upload Invoice File by API Gateway Endpoint Type: Select Regional. Click Create API to finish.\nStep 2: Create Resource Resource: /uploads In PostInvoiceAPI, select Create resource. Enter information:\nResource path: / Resource name: uploads Click Create resource.\nStep 3: Create Method Method: POST In the resource tree, select /uploads.\nClick Create method.\nConfigure in Create method:\nMethod type: POST. Integration type: Lambda function. Lambda proxy integration: Enabled. Lambda function: UploadInvoiceFileFunction. Click Create method. Method: PUT In the resource tree, select /uploads.\nClick Create method.\nConfigure in Create method:\nMethod type: PUT. Integration type: Lambda function. Lambda proxy integration: Enabled. Lambda function: UploadInvoiceFileFunction. Click Create method. Step 4: Enable CORS for methods In the resource tree of PostInvoiceAPI, select resource /uploads. Click Enable CORS. In Access-Control-Allow-Methods, enable CORS for:\nPOST PUT Click Save.\nStep 5: Deploy the API Click Deploy API. In the Deploy API modal:\nStage: [New Stage]. Stage name: dev. Deployment description: Test API Method POST. Click Deploy. "
},
{
	"uri": "/2-environmentsetup/2.2-createiamuserandattachpolicy/",
	"title": "Create IAM User and Assign Permissions",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will create an IAM User with access to AWS services via the Command Line Interface (CLI) or SDK. This user will be assigned the two previously created policies to interact with the backend and frontend of the Serverless Invoices Scanner system.\nStep 1: Access the IAM Console Go to AWS Console, search for IAM, then click on IAM in the results. In the left-hand menu, select Users. Click the Create user button to start creating a new IAM User. Step 2: Configure IAM User User name: ai-invoice-scanner-user Check the box: Provide user access to the AWS Management Console. Select: I want to create an IAM user. Under Console password:\nSelect: Custom password. Set password: Admin@123 Uncheck: Users must create a new password at next sign-in. Unchecking this option allows the user to avoid being prompted to change the password on their first login.\nClick Next to proceed to the permissions step. 💡 You can choose a different password according to your internal security policy.\nStep 3: Attach Policies to the IAM User In the Set permissions section, choose Attach policies directly. Search for and select the following policies:\nAIInvoiceScannerFullPolicy AmplifyAdminPolicy Click Next to continue. Click Create user to finish creating the IAM User. Step 4: Save Login Information Click Download .csv file to save the Access Key ID and console password. The file will be downloaded as an Excel sheet — be sure to store this file securely for future use. Step 5: Verify IAM User Information Click Return to users list to go back to the Users list. The newly created IAM User will be listed as shown: Click the user to view its detailed information. Step 6: Create Access Key On the user detail page, click Create access key. Select Command Line Interface (CLI). Check the box: I understand the above recommendation and want to proceed to create an access key. Click Next to proceed. Step 7: Add a Description for the Access Key Description tag value: AI Invoice Scanner Project Click Create access key. Step 8: Backup Access Key Once the access key is successfully created, AWS will display:\nAccess Key ID ✅ Secret Access Key 🔐 ⚠️ Note: This is the only time you will see the Secret Access Key. Store it securely and never share it on GitHub or any public platform.\nClick Download .csv file and save the file on your computer for future use. Click Done to finish. Step 9: Verify the Access Key Return to the Security credentials tab, and you will see the Access Key ID listed. Check that the Access Key is in Active status. 💡 Note: Make sure you saved the Secret Access Key from the previous step. If not, you’ll need to delete and recreate a new access key.\nYou may deactivate or delete this key when no longer needed. Never commit Access Keys to GitHub or share them publicly. If your key is exposed, go to IAM \u0026gt; User \u0026gt; Access Keys \u0026gt; Deactivate then Delete. "
},
{
	"uri": "/3-aipoweredinvoiceprocessing/3.2-createlambdafunction-upload/",
	"title": "Create Lambda Function #1",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will create the first Lambda Function named UploadInvoiceFileFunction. This function is triggered when a user uploads an invoice file to the S3 bucket. It then uses Amazon Textract to extract text, Amazon Bedrock to analyze and understand the content, and finally stores the extracted information into DynamoDB.\nStep 1: Open the Lambda Console Log in to the AWS Console, search for Lambda, and select Lambda. ⚠️ Note: Make sure you are in the correct Region: N. Virginia (us-east-1) before creating the Lambda function. This is the region where you created the S3 bucket, DynamoDB table, and registered Amazon Bedrock. If you choose the wrong region, Lambda won\u0026rsquo;t be able to access the system\u0026rsquo;s other services.\nClick Create function. Step 2: Configure the Lambda Function Under Author from scratch, fill in the following details:\nFunction name: UploadInvoiceFileFunction Runtime: Python 3.12 Architecture: x86_64 Permissions: Choose Use an existing role Existing role: LambdaExecutionRole-AIInvoiceScanner (created in the previous step) Click Create function to proceed. Step 3: Add Python Code Once the function is created, scroll down to the Code section in the Lambda interface.\nPaste the entire Python code below, replacing the default content:\nimport boto3 import json import uuid import base64 import re import time from decimal import Decimal # AWS clients s3 = boto3.client(\u0026#39;s3\u0026#39;) textract = boto3.client(\u0026#39;textract\u0026#39;) dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) bedrock = boto3.client(\u0026#39;bedrock-runtime\u0026#39;, region_name=\u0026#39;us-east-1\u0026#39;) # Constants BUCKET_NAME = \u0026#39;invoice-upload-s3-bucket\u0026#39; table = dynamodb.Table(\u0026#39;InvoiceData\u0026#39;) def decimal_default(obj): if isinstance(obj, Decimal): return float(round(obj, 2)) def make_response(status_code, body_dict): return { \u0026#39;statusCode\u0026#39;: status_code, \u0026#39;headers\u0026#39;: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Credentials\u0026#39;: True, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;OPTIONS,POST\u0026#39; }, \u0026#39;body\u0026#39;: json.dumps(body_dict, default=decimal_default) } def lambda_handler(event, context): print(\u0026#34;🔍 Incoming event:\u0026#34;) print(json.dumps(event)) try: # === CASE 1: API Gateway POST upload file === if \u0026#34;body\u0026#34; in event and isinstance(event[\u0026#39;body\u0026#39;], str) and not (\u0026#34;Records\u0026#34; in event): body = json.loads(event[\u0026#39;body\u0026#39;]) file_data = base64.b64decode(body[\u0026#39;file\u0026#39;]) filename = body.get(\u0026#39;filename\u0026#39;, f\u0026#39;invoice_{uuid.uuid4()}.png\u0026#39;) key = f\u0026#39;uploads/{filename}\u0026#39; s3.put_object( Bucket=BUCKET_NAME, Key=key, Body=file_data, ContentType=\u0026#39;image/png\u0026#39; ) print(f\u0026#34;✅ Uploaded \u0026#39;{key}\u0026#39;\u0026#34;) return make_response(200, { \u0026#39;message\u0026#39;: \u0026#39;Upload thành công\u0026#39;, \u0026#39;s3_path\u0026#39;: f\u0026#39;s3://{BUCKET_NAME}/{key}\u0026#39; }) # === CASE 2: S3 Trigger xử lý hóa đơn === elif \u0026#34;Records\u0026#34; in event and \u0026#34;s3\u0026#34; in event[\u0026#34;Records\u0026#34;][0]: bucket = event[\u0026#39;Records\u0026#39;][0][\u0026#39;s3\u0026#39;][\u0026#39;bucket\u0026#39;][\u0026#39;name\u0026#39;] key = event[\u0026#39;Records\u0026#39;][0][\u0026#39;s3\u0026#39;][\u0026#39;object\u0026#39;][\u0026#39;key\u0026#39;] print(f\u0026#34;📥 Trigger từ S3: bucket={bucket}, key={key}\u0026#34;) # 1. Textract textract_response = textract.detect_document_text( Document={\u0026#39;S3Object\u0026#39;: {\u0026#39;Bucket\u0026#39;: bucket, \u0026#39;Name\u0026#39;: key}} ) extracted_text = \u0026#39; \u0026#39;.join( [block[\u0026#39;Text\u0026#39;] for block in textract_response[\u0026#39;Blocks\u0026#39;] if block[\u0026#39;BlockType\u0026#39;] == \u0026#39;LINE\u0026#39;] ) if len(extracted_text.strip()) \u0026lt; 20: return make_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Không phát hiện được nội dung hợp lệ từ ảnh.\u0026#39;}) # 2. Prompt cho Bedrock prompt = ( \u0026#34;You are a precise invoice data parser. Extract structured data from the invoice text below.\\n\u0026#34; \u0026#34;Return ONLY valid JSON with fields:\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34; \\\u0026#34;InvoiceId\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;CustomerName\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;InvoiceDate\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;DueDate\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;PurchaseOrderNumber\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;Company\\\u0026#34;: {\\\u0026#34;Name\\\u0026#34;: \\\u0026#34;\\\u0026#34;, \\\u0026#34;Address\\\u0026#34;: \\\u0026#34;\\\u0026#34;},\\n\u0026#34; \u0026#34; \\\u0026#34;BillTo\\\u0026#34;: {\\\u0026#34;Name\\\u0026#34;: \\\u0026#34;\\\u0026#34;, \\\u0026#34;Address\\\u0026#34;: \\\u0026#34;\\\u0026#34;},\\n\u0026#34; \u0026#34; \\\u0026#34;ShipTo\\\u0026#34;: {\\\u0026#34;Name\\\u0026#34;: \\\u0026#34;\\\u0026#34;, \\\u0026#34;Address\\\u0026#34;: \\\u0026#34;\\\u0026#34;},\\n\u0026#34; \u0026#34; \\\u0026#34;Items\\\u0026#34;: [\\n\u0026#34; \u0026#34; {\\\u0026#34;Description\\\u0026#34;: \\\u0026#34;\\\u0026#34;, \\\u0026#34;Quantity\\\u0026#34;: 0, \\\u0026#34;UnitPrice\\\u0026#34;: 0.0, \\\u0026#34;Amount\\\u0026#34;: 0.0}\\n\u0026#34; \u0026#34; ],\\n\u0026#34; \u0026#34; \\\u0026#34;Subtotal\\\u0026#34;: 0.0,\\n\u0026#34; \u0026#34; \\\u0026#34;Tax\\\u0026#34;: {\\\u0026#34;Rate\\\u0026#34;: 0.0, \\\u0026#34;Amount\\\u0026#34;: 0.0},\\n\u0026#34; \u0026#34; \\\u0026#34;TotalAmount\\\u0026#34;: 0.0,\\n\u0026#34; \u0026#34; \\\u0026#34;Currency\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\n\u0026#34; \u0026#34; \\\u0026#34;PaymentTerms\\\u0026#34;: {\\\u0026#34;DueWithinDays\\\u0026#34;: 0, \\\u0026#34;PayableTo\\\u0026#34;: \\\u0026#34;\\\u0026#34;}\\n\u0026#34; \u0026#34;}\\n\u0026#34; \u0026#34;Rules:\\n\u0026#34; \u0026#34;- Normalize all dates to ISO format YYYY-MM-DD.\\n\u0026#34; \u0026#34;- If the text uses DD/MM/YYYY, convert to YYYY-MM-DD correctly.\\n\u0026#34; \u0026#34;- Ensure numeric values are floats.\\n\u0026#34; \u0026#34;- If a value is missing, set it to null.\\n\u0026#34; \u0026#34;- No explanation, no markdown, no extra text.\\n\\n\u0026#34; f\u0026#34;Invoice text:\\n{extracted_text}\u0026#34; ) messages = [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: [{\u0026#34;text\u0026#34;: prompt}]}] response = bedrock.converse( modelId=\u0026#34;amazon.nova-pro-v1:0\u0026#34;, messages=messages, inferenceConfig={\u0026#34;maxTokens\u0026#34;: 1024, \u0026#34;temperature\u0026#34;: 0.2, \u0026#34;topP\u0026#34;: 0.9} ) ai_text = response[\u0026#39;output\u0026#39;][\u0026#39;message\u0026#39;][\u0026#39;content\u0026#39;][0][\u0026#39;text\u0026#39;] print(\u0026#34;🧠 Bedrock raw output:\u0026#34;, ai_text) # 3. Parse JSON output try: match = re.search(r\u0026#39;({.*})\u0026#39;, ai_text, re.DOTALL | re.MULTILINE) json_str = match.group(1) if match else ai_text.strip() result_json = json.loads(json_str, parse_float=Decimal) except Exception as e: print(\u0026#34;❌ Lỗi parse JSON:\u0026#34;, str(e)) result_json = {\u0026#34;error\u0026#34;: \u0026#34;Invalid JSON\u0026#34;, \u0026#34;raw_output\u0026#34;: ai_text} # 4. Lưu vào DynamoDB (thêm trường Tags rỗng) result_json[\u0026#39;S3Object\u0026#39;] = f\u0026#39;s3://{bucket}/{key}\u0026#39; if \u0026#39;Tags\u0026#39; not in result_json: result_json[\u0026#39;Tags\u0026#39;] = [] table.put_item(Item=result_json) print(\u0026#34;✅ Lưu vào DynamoDB thành công.\u0026#34;) return make_response(200, {\u0026#39;message\u0026#39;: \u0026#39;Xử lý thành công\u0026#39;, \u0026#39;parsed\u0026#39;: result_json}) else: return make_response(400, {\u0026#39;error\u0026#39;: \u0026#39;Request không hợp lệ.\u0026#39;}) except Exception as e: print(\u0026#34;❌ Lỗi tổng quát:\u0026#34;, str(e)) return make_response(500, {\u0026#39;error\u0026#39;: str(e)}) Click Deploy to apply the changes. Step 4: Configure Timeout and Memory Go to the Configuration \u0026gt; General configuration tab. Click Edit. Change the following values:\nMemory (MB): 1024 Timeout: 1 minute Click Save. Conclusion You have successfully created the first Lambda Function in the system: UploadInvoiceFileFunction.\nThis function is automatically triggered whenever a user uploads an invoice to the uploads/ folder in S3. It uses Amazon Textract to extract text from the invoice. Then uses Amazon Bedrock Nova Pro to analyze the content. Finally, the data is stored in DynamoDB for querying and display purposes. "
},
{
	"uri": "/2-environmentsetup/",
	"title": "Environment Setup",
	"tags": [],
	"description": "",
	"content": "Overview In this section, you’ll set up the required AWS resources for the system, including IAM, S3, DynamoDB, and Amazon Cognito for authentication.\nContents Create IAM Policies Create IAM User and Permissions Log In with IAM User Create S3 Bucket Create DynamoDB Table Request Nova Pro Access "
},
{
	"uri": "/5-testwithpostman/5.2-testgetallinvoices/",
	"title": "Testing Retrieval of All Invoices",
	"tags": [],
	"description": "",
	"content": "Prerequisites ⚠️ Previously we only demonstrated uploading \u0026ldquo;demo_invoice.png\u0026rdquo;. Please upload the remaining 2 invoice files as well!\nStep 1: Create Postman Collection Open Postman application and click the \u0026quot;+\u0026quot; button to create a new collection. Select Blank Collection. Name it: InvoiceGetAPI-Tests Step 2: Create Request Within the newly created collection, click the \u0026quot;+\u0026quot; button to add a request. Name the request: Get All Invoices. Select the POST method. Go to API Gateway and select the API: GetInvoiceAPI. Navigate to the Stages section. Click the \u0026quot;+\u0026quot; button to reveal the /invoice endpoint path as shown below: Select the GET method and copy the Invoke URL. Paste the Invoke URL into Postman as follows: Click the Send button to view results. A successful response will appear as follows: Verify that all 3 invoices are returned to confirm success ✅\n"
},
{
	"uri": "/7-cleanup/7.3-removedynamodb/",
	"title": "Delete DynamoDB",
	"tags": [],
	"description": "",
	"content": "Steps to follow Open AWS Management Console → Search for DynamoDB service. In the Tables tab, locate and select the InvoiceData table → Click Delete. Confirm by entering: confirm → Click Delete. Check InvoiceData was deleted successfully. "
},
{
	"uri": "/3-aipoweredinvoiceprocessing/",
	"title": "AI-powered Invoice Processing",
	"tags": [],
	"description": "",
	"content": "Overview In this section, you will deploy Lambda functions to process invoices using Artificial Intelligence (AI). Specifically, you will create Lambda functions responsible for extracting data from invoices using Amazon Textract and Amazon Bedrock, as well as retrieving data from DynamoDB through API Gateway.\nContents Create IAM Role Create Lambda Function #1 Test Lambda Function #1 Create Lambda Function #2 Test Lambda Function #2 "
},
{
	"uri": "/2-environmentsetup/2.3-loginwithiamuser/",
	"title": "Login with IAM User",
	"tags": [],
	"description": "",
	"content": "Objective In this step, you will log in using the IAM User that has been granted permissions to use the AWS Console. This is a mandatory step before deploying any resources.\nStep 1: Open the browser in Incognito mode Open Google Chrome (or your current browser) in Incognito mode. Quick shortcut: Press Ctrl + Shift + N. This prevents session conflicts if you\u0026rsquo;re logged into multiple AWS accounts. Step 2: Open the Excel file containing IAM User credentials Open the Excel file you downloaded from the system administrator.\nIn this file, you\u0026rsquo;ll find the following information:\nAccount ID IAM User name Password This information is usually provided to you via email or as an attachment from the project manager.\nStep 3: Visit the IAM login page Go to the IAM login URL in the following format:\nhttps://\u0026lt;ACCOUNT_ID\u0026gt;.signin.aws.amazon.com/console Replace \u0026lt;ACCOUNT_ID\u0026gt; with the AWS account ID provided to you (e.g., 123456789012).\nStep 4: Enter login credentials IAM user name: Enter the correct IAM username from the Excel file. Password: Enter the corresponding password. Then click the Sign in button to access the system. Step 5: Set Region to N. Virginia After successfully logging into the AWS Management Console:\nLook at the top-right corner of the screen. Click on the current Region name. Select N. Virginia (us-east-1). All system resources will be deployed in the us-east-1 (N. Virginia) Region. Make sure you are operating in the correct region.\nConclusion You have successfully logged in as an IAM User. In the next step, you will create an S3 Bucket in the us-east-1 Region.\n"
},
{
	"uri": "/5-testwithpostman/5.3-testgetinvoiceid/",
	"title": "Testing Invoice Retrieval by ID",
	"tags": [],
	"description": "",
	"content": "Step 1: Create Request In the InvoiceGetAPI-Tests Collection, click the \u0026quot;+\u0026quot; button to create a new request. Name the request: Get Invoices By ID. Select the GET method. Go to API Gateway and select the API: GetInvoiceAPI.\nNavigate to the Stages section.\nClick the \u0026quot;+\u0026quot; button to reveal the /invoice/{id} endpoint path as shown below:\nSelect the GET method and copy the Invoke URL. Paste the Invoke URL into Postman as follows: Replace {id} in the API endpoint with an actual Invoice ID from DynamoDB: https://x4uqolxky6.execute-api.us-east-1.amazonaws.com/dev/invoice/\u0026lt;InvoiceId_from_DynamoDB\u0026gt; Click the Send button to view results. A successful response will appear as follows: You can now test the remaining 2 invoice files!\n"
},
{
	"uri": "/3-aipoweredinvoiceprocessing/3.3-testlambdafunction-upload/",
	"title": "Testing Lambda Function #1",
	"tags": [],
	"description": "",
	"content": "Tổng quan In this step, you will test the UploadInvoiceFileFunction Lambda Function by uploading a sample invoice file to the S3 bucket. The purpose of this test is to verify the entire processing workflow, from file upload to S3, data extraction with Textract, analysis with Bedrock, and storage in DynamoDB.\nPrerequisites Before testing the Lambda function, prepare a sample invoice file to upload. Please download the following file:\nDownload demo_invoice.png sample file 🔧 Note: If you use a different invoice file, rename it to demo_invoice.png before uploading to the uploads/ folder in S3.\nStep 1: Upload Invoice File to S3 Go to Amazon S3 Console. Open the bucket named: invoice-upload-s3-bucket. Open the uploads/ folder. Click Upload. Click Add files. Choose the file: demo_invoice.png. Click Upload to upload the file. Check the file after upload. Step 2: Create Test Event in Lambda Console Open AWS Lambda Console. Navigate to the UploadInvoiceFileFunction function.\nClick the Test tab to create a new Test Event.\nEvent name: TestUploadInvoice.\nPaste the following JSON content into the event section: { \u0026#34;Records\u0026#34;: [ { \u0026#34;eventVersion\u0026#34;: \u0026#34;2.1\u0026#34;, \u0026#34;eventSource\u0026#34;: \u0026#34;aws:s3\u0026#34;, \u0026#34;awsRegion\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;eventTime\u0026#34;: \u0026#34;2025-07-31T12:00:00.000Z\u0026#34;, \u0026#34;eventName\u0026#34;: \u0026#34;ObjectCreated:Put\u0026#34;, \u0026#34;s3\u0026#34;: { \u0026#34;bucket\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;invoice-upload-s3-bucket\u0026#34; }, \u0026#34;object\u0026#34;: { \u0026#34;key\u0026#34;: \u0026#34;uploads/demo_invoice.png\u0026#34; } } } ] } Click Save. Step 3: Run the Test After creating the Test Event, click the Test button to run it. Observe the Execution results displayed after the run:\nIf successful, you will see: Status: succeeded along with log output. Step 4: View Detailed Logs in CloudWatch In Lambda Console, select the Monitor tab. Click View CloudWatch logs. Open the latest log stream. Review the logs. Step 5: Check Data in DynamoDB Go to the AWS DynamoDB Console. Open the InvoiceData table. Click Explore table items. Search for the record with InvoiceId corresponding to demo_invoice.png to confirm it was saved. ⚠️ Warning: Ensure all resources (Lambda, S3, DynamoDB, Textract, and Bedrock) are in the same region: N. Virginia (us-east-1) to ensure proper system synchronization.\n"
},
{
	"uri": "/7-cleanup/7.4-removes3bucket/",
	"title": "Delete S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Steps to follow Open AWS Management Console → Search for S3 service. In the Buckets list, find and select the following bucket: Click Empty. Confirm by entering: permanently delete → Click Empty. Go back and select that bucket and press Delete. Confirm by entering that bucket name and press Delete bucket. Repeat the above operation with invoice-upload-s3-bucket. "
},
{
	"uri": "/3-aipoweredinvoiceprocessing/3.4-createlambdafunction-fetch/",
	"title": "Create Lambda Function #2",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will create the second Lambda Function named FetchInvoiceDetailsFunction. This function is responsible for querying or updating invoice information in DynamoDB to serve requests from the API Gateway.\nStep 1: Access the Lambda Console Open AWS Lambda Console Click Create function. Step 2: Configure Lambda Function In the Author from scratch section, enter the following details:\nFunction name: FetchInvoiceDetailsFunction Runtime: Python 3.12 Architecture: x86_64 Permissions: Select Use an existing role Existing role: LambdaExecutionRole-AIInvoiceScanner Click Create function. Step 3: Add Python Source Code Scroll down to the Code section and replace the default content with the following Python code: import boto3 import json from decimal import Decimal from boto3.dynamodb.conditions import Key dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;InvoiceData\u0026#39;) def decimal_default(obj): if isinstance(obj, Decimal): return float(obj) def lambda_handler(event, context): print(\u0026#34;DEBUG EVENT:\u0026#34;, json.dumps(event)) headers = { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Credentials\u0026#34;: True, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;OPTIONS,GET,PATCH\u0026#34; } try: http_method = event.get(\u0026#34;httpMethod\u0026#34;, \u0026#34;\u0026#34;) resource = event.get(\u0026#34;resource\u0026#34;, \u0026#34;\u0026#34;) path_params = event.get(\u0026#34;pathParameters\u0026#34;) or {} invoice_id = path_params.get(\u0026#34;id\u0026#34;) # === PATCH /invoice/starred/{id} === if http_method == \u0026#34;PATCH\u0026#34; and invoice_id and resource == \u0026#34;/invoice/starred/{id}\u0026#34;: if not event.get(\u0026#34;body\u0026#34;): return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Body must not be empty\u0026#39;}) } # Kiểm tra tồn tại invoice existing = table.get_item(Key={\u0026#39;InvoiceId\u0026#39;: invoice_id}) if \u0026#39;Item\u0026#39; not in existing: return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: f\u0026#39;Invoice with the given ID was not found: {invoice_id}.\u0026#39;}) } body = json.loads(event[\u0026#34;body\u0026#34;]) starred = body.get(\u0026#34;starred\u0026#34;) if not isinstance(starred, bool): return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;The \u0026#39;starred\u0026#39; field must be a boolean\u0026#39;}) } starred_str = \u0026#34;true\u0026#34; if starred else \u0026#34;false\u0026#34; table.update_item( Key={\u0026#39;InvoiceId\u0026#39;: invoice_id}, UpdateExpression=\u0026#34;SET Starred = :starred\u0026#34;, ExpressionAttributeValues={\u0026#39;:starred\u0026#39;: starred_str} ) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;message\u0026#39;: \u0026#39;Starred updated successfully\u0026#39;, \u0026#39;InvoiceId\u0026#39;: invoice_id, \u0026#39;Starred\u0026#39;: starred_str}) } # === PATCH /invoice/tags/{id} === if http_method == \u0026#34;PATCH\u0026#34; and invoice_id and resource == \u0026#34;/invoice/tags/{id}\u0026#34;: if not event.get(\u0026#34;body\u0026#34;): return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Body must not be empty\u0026#39;}) } # Kiểm tra tồn tại invoice existing = table.get_item(Key={\u0026#39;InvoiceId\u0026#39;: invoice_id}) if \u0026#39;Item\u0026#39; not in existing: return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: f\u0026#39;Invoice with the given ID was not found: {invoice_id}.\u0026#39;}) } body = json.loads(event[\u0026#34;body\u0026#34;]) tags = body.get(\u0026#34;tags\u0026#34;) if not isinstance(tags, list): return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Tags must be an array\u0026#39;}) } table.update_item( Key={\u0026#39;InvoiceId\u0026#39;: invoice_id}, UpdateExpression=\u0026#34;SET Tags = :tags\u0026#34;, ExpressionAttributeValues={\u0026#39;:tags\u0026#39;: tags} ) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;message\u0026#39;: \u0026#39;Tags updated successfully\u0026#39;, \u0026#39;InvoiceId\u0026#39;: invoice_id, \u0026#39;Tags\u0026#39;: tags}) } # === GET /invoice/starred === if http_method == \u0026#34;GET\u0026#34; and resource == \u0026#34;/invoice/starred\u0026#34;: try: response = table.query( IndexName=\u0026#34;StarredInvoicesIndex\u0026#34;, KeyConditionExpression=Key(\u0026#34;Starred\u0026#34;).eq(\u0026#34;true\u0026#34;) ) items = response.get(\u0026#34;Items\u0026#34;, []) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps(items, default=decimal_default) } except Exception as e: return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: f\u0026#39;Error querying StarredInvoicesIndex: {str(e)}\u0026#39;}) } # === GET /invoice/{id} === if invoice_id and http_method == \u0026#34;GET\u0026#34;: response = table.get_item(Key={\u0026#39;InvoiceId\u0026#39;: invoice_id}) if \u0026#39;Item\u0026#39; not in response: return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: f\u0026#39;Invoice with the given ID was not found: {invoice_id}.\u0026#39;}) } return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps(response[\u0026#39;Item\u0026#39;], default=decimal_default) } # === GET /invoice?name=... === if http_method == \u0026#34;GET\u0026#34; and event.get(\u0026#39;queryStringParameters\u0026#39;) and event[\u0026#39;queryStringParameters\u0026#39;].get(\u0026#39;name\u0026#39;): name = event[\u0026#39;queryStringParameters\u0026#39;][\u0026#39;name\u0026#39;] try: response = table.query( IndexName=\u0026#39;CustomerName-index\u0026#39;, KeyConditionExpression=Key(\u0026#39;CustomerName\u0026#39;).eq(name) ) items = response.get(\u0026#39;Items\u0026#39;, []) except Exception as e: return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: f\u0026#39;Error querying CustomerName: {str(e)}\u0026#39;}) } if not items: return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: f\u0026#39;No invoice found with the customer name: {name}.\u0026#39;}) } return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps(items, default=decimal_default) } # === GET /invoice (tất cả) === if http_method == \u0026#34;GET\u0026#34;: response = table.scan() items = response.get(\u0026#39;Items\u0026#39;, []) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps(items, default=decimal_default) } return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Method not supported\u0026#39;}) } except Exception as e: return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: headers, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: str(e)}) } Click Deploy to save and apply the source code. Step 4: Configure Timeout and Memory Go to Configuration \u0026gt; General configuration, click Edit. Configure the information as follows:\nDescription: Retrieves invoice data from DynamoDB based on invoice ID via API Gateway request Memory (MB): 128 Timeout: 3 seconds Click Save. Kết luận You have successfully created the FetchInvoiceDetailsFunction Lambda Function, used to handle querying and updating invoice data from DynamoDB. This function will be connected to API Gateway to serve requests from the frontend.\n"
},
{
	"uri": "/2-environmentsetup/2.4-creates3bucketforinvoices/",
	"title": "Create S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will create an S3 bucket to store invoice files uploaded by users. This bucket will be created in the us-east-1 region, and you will also configure an event notification to trigger a Lambda function whenever a new file is uploaded into a specific folder.\nStep 1: Access S3 Console Log in to the AWS Console, search for S3, then select S3 from the results. 💡 Note: Before creating the bucket, make sure you have selected the correct region us-east-1 in the upper right corner of the AWS Console screen.\nCreating the S3 bucket in the correct region is crucial for services like Lambda or Textract to work seamlessly.\nClick Create bucket to start creating a new one. Step 2: Configure the bucket Bucket name: invoice-upload-s3-bucket 💡 Note: Bucket names must be globally unique. You may add a suffix if the name is already taken, e.g., invoice-upload-s3-bucket-123456.\nIn the Object Ownership section, select ACLs disabled.\nBlock Public Access settings: keep default settings (all enabled) to ensure data is not public.\nIn the Bucket Versioning section, select Disabled. In the Default encryption section, choose Amazon S3 managed keys (SSE-S3).\nClick Create bucket to finish.\nVerify that the Bucket has been created. Step 3: Create the uploads/ folder Inside the newly created bucket, click Create folder. Name the folder: uploads Click Create folder to confirm. Verify that the folder has been created. Step 7: Set up Event Notification Go to the Properties tab of the bucket. Scroll down to Event notifications → select Create event notification. Configure as follows:\nName: TriggerLambdaOnUpload Prefix: uploads/ Suffix: (leave blank) Event types: select PUT (All object create events) Destination: select Lambda function Lambda function: select UploadInvoiceFileFunction Click Save changes to complete the setup. If you don’t see the Lambda function listed, make sure it was created in the correct region (us-east-1) and that the Lambda\u0026rsquo;s IAM role has the s3:PutBucketNotification permission.\n"
},
{
	"uri": "/4-deployingapigateway/",
	"title": "Deploying API Gateway",
	"tags": [],
	"description": "",
	"content": "Tổng quan In this section, you will deploy API Gateway to enable communication between the frontend and backend via two main APIs: POST and GET.\nNội dung Create API Gateway (GET) Create API Gateway (POST) "
},
{
	"uri": "/5-testwithpostman/5.4-testgetinvoicesstarred/",
	"title": "Testing Retrieval of Starred Invoices",
	"tags": [],
	"description": "",
	"content": "Step 1: Create Request In the InvoiceGetAPI-Tests Collection, click the \u0026quot;+\u0026quot; button to create a new request. Name the request: Get All Invoices Starred. Select the GET method. Go to API Gateway and select the API: GetInvoiceAPI.\nNavigate to the Stages section.\nClick the \u0026quot;+\u0026quot; button to reveal the /invoice/starred endpoint path as shown below:\nSelect the GET method and copy the Invoke URL. Paste the Invoke URL into Postman as follows: Click the Send button to view results. The response will appear as follows: When the response shows [], it means there are currently no starred invoices\n"
},
{
	"uri": "/7-cleanup/7.5-removecloudwatch/",
	"title": "Remove CloudWatch Alarms",
	"tags": [],
	"description": "",
	"content": "Steps Open AWS Management Console → Search for CloudWatch service. In the left menu, select Logs → Select Log groups. Find logs related to the project → Select the logs to delete. Click Actions → Select Delete log group(s). Press Delete. Check CloudWatch after deletion. "
},
{
	"uri": "/2-environmentsetup/2.5-createdynamodbtableforinvoices/",
	"title": "Create DynamoDB Table",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will create a DynamoDB Table to store invoice information after it is processed by the Lambda function. The table will use on-demand mode and have 2 additional Global Secondary Indexes (GSIs) to support queries by customer name and starred invoices.\nStep 1: Access DynamoDB Console Log in to AWS Console, search for DynamoDB, then select DynamoDB in the results. 💡 Note: Before clicking Create table, make sure you have selected the correct region as US East (N. Virginia) (us-east-1) in the upper right corner of the AWS Console screen.\nClick Create table to start creating a new table. Step 2: Configure DynamoDB table Table name: InvoiceData\nPartition key:\nName: InvoiceId Type: String Skip the Sort key section (not necessary). In the Table settings section, Select Default settings to switch to On-demand capacity mode. Click Create table to finish. Step 3: Add Global Secondary Index (GSI) Once the InvoiceData table is successfully created, you will add two secondary indexes:\nGSI #1: CustomerName-index In the table details page, select the Indexes tab. Click Create index. Configuration: Partition key: CustomerName Data type: String Sort key: (leave blank) Projected attributes: select All Click Create index. GSI #2: StarredInvoicesIndex Click Create index again to create the second GSI. Configuration: Partition key: IsStarred (type String) Sort key: CreatedAt (type String) Index name: StarredInvoicesIndex Projected attributes: select All Click Create index. Make sure both GSIs CustomerName-index and StarredInvoicesIndex are in ACTIVE status before continuing with Lambda function configuration. ⚠️ If the GSI status is still Creating, you need to wait a few minutes until it changes to Active before making a query or deploying a Lambda to access the GSI.\n"
},
{
	"uri": "/3-aipoweredinvoiceprocessing/3.5-testlambdafunction-fetch/",
	"title": "Test Lambda Function #2",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will test the FetchInvoiceDetailsFunction Lambda Function. This function is responsible for reading and updating invoice information from DynamoDB through API endpoints such as GET or PATCH. Testing will help verify that the Lambda function works correctly when receiving input from API Gateway.\n⚠️ Make sure you already have at least one invoice file in your S3 Bucket and a corresponding record in the InvoiceData DynamoDB table before starting the test.\nStep 1: Create a Test Event for Data Retrieval Open the AWS Lambda Console.\nSelect the FetchInvoiceDetailsFunction function.\nSwitch to the Test tab.\nScroll down to the Test event section and configure it as follows:\nEvent name: TestGetInvoice Template: Hello World Paste the following JSON into the event content:\n{ \u0026#34;httpMethod\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/invoice/demo_invoice.png\u0026#34;, \u0026#34;pathParameters\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;Your_InvoiceId\u0026#34; } } 📌 Replace the \u0026quot;id\u0026quot; value with a valid InvoiceId that exists in the InvoiceData DynamoDB table.\nScroll up and click Save.\nStep 2: Run the Test After creating the Test Event, click the Test button to execute it.\nObserve the Execution results displayed after running:\nIf successful, you will see: Status: succeeded along with log output showing the processing details. "
},
{
	"uri": "/5-testwithpostman/",
	"title": "Test with Postman",
	"tags": [],
	"description": "",
	"content": "\rPort Forwarding is a useful way to redirect network traffic from one IP address - Port to another IP address - Port. With Port Forwarding we can access an EC2 instance located in the private subnet from our workstation.\nWe will configure Port Forwarding for the RDP connection between our machine and Private Windows Instance located in the private subnet we created for this exercise.\nCreate IAM user with permission to connect SSM Go to IAM service management console Click Users , then click Add users. At the Add user page. In the User name field, enter Portfwd. Click on Access key - Programmatic access. Click Next: Permissions. Click Attach existing policies directly.\nIn the search box, enter ssm. Click on AmazonSSMFullAccess. Click Next: Tags, click Next: Reviews. Click Create user. Save Access key ID and Secret access key information to perform AWS CLI configuration.\nInstall and Configure AWS CLI and Session Manager Plugin To perform this hands-on, make sure your workstation has AWS CLI and Session Manager Plugin installed -manager-working-with-install-plugin.html)\nMore hands-on tutorials on installing and configuring the AWS CLI can be found here.\nWith Windows, when extracting the Session Manager Plugin installation folder, run the install.bat file with Administrator permission to perform the installation.\nImplement Portforwarding Run the command below in Command Prompt on your machine to configure Port Forwarding. aws ssm start-session --target (your ID windows instance) --document-name AWS-StartPortForwardingSession --parameters portNumber=\u0026#34;3389\u0026#34;,localPortNumber=\u0026#34;9999\u0026#34; --region (your region) Windows Private Instance Instance ID information can be found when you view the EC2 Windows Private Instance server details.\nExample command: C:\\Windows\\system32\u0026gt;aws ssm start-session --target i-06343d7377486760c --document-name AWS-StartPortForwardingSession --parameters portNumber=\u0026#34;3389\u0026#34;,localPortNumber=\u0026#34;9999\u0026#34; --region ap-southeast-1 If your command gives an error like below: SessionManagerPlugin is not found. Please refer to SessionManager Documentation here: http://docs.aws.amazon.com/console/systems-manager/session-manager-plugin-not-found\nProve that you have not successfully installed the Session Manager Plugin. You may need to relaunch Command Prompt after installing Session Manager Plugin.\nConnect to the Private Windows Instance you created using the Remote Desktop tool on your workstation. In the Computer section: enter localhost:9999. Return to the administration interface of the System Manager - Session Manager service. Click tab Session history. We will see session logs with Document name AWS-StartPortForwardingSession. Congratulations on completing the lab on how to use Session Manager to connect and store session logs in S3 bucket. Remember to perform resource cleanup to avoid unintended costs.\n"
},
{
	"uri": "/5-testwithpostman/5.5-testupdatestatusstarred/",
	"title": "Testing Invoice Star Status Update",
	"tags": [],
	"description": "",
	"content": "Step 1: Create Request In the InvoiceGetAPI-Tests Collection, click the \u0026quot;+\u0026quot; button to create a new request. Name the request: Update Invoice Starred. Select the PATCH method. Go to API Gateway and select the API: GetInvoiceAPI.\nNavigate to the Stages section.\nClick the \u0026quot;+\u0026quot; button to reveal the /invoice/starred/{id} endpoint path as shown below:\nSelect the PATCH method and copy the Invoke URL. Paste the Invoke URL into Postman as follows: Replace {id} in the API endpoint with an actual Invoice ID from DynamoDB: https://x4uqolxky6.execute-api.us-east-1.amazonaws.com/dev/invoice/starred/\u0026lt;InvoiceId_from_DynamoDB\u0026gt; Go to the Body tab → Select raw → Choose JSON. Paste the following JSON code into Postman to mark the invoice: { \u0026#34;starred\u0026#34;: true } Click the Send button to view results. The response will appear as follows: Check the Starred field in DynamoDB to verify the update. "
},
{
	"uri": "/7-cleanup/7.6-removeiam/",
	"title": "Remove IAM User and Policy",
	"tags": [],
	"description": "",
	"content": "\r⚠️ Note: Please log in with root user to remove IAM service and Policy.\nSteps Open AWS Management Console → Search for IAM service. In the left navigation bar, select Users. Find and select the user ai-invoice-scanner-user to go to the user\u0026rsquo;s details page. Scroll down to the Permissions policies section, select all the policies assigned to the user, then click the Remove button. Click Remove policies to confirm removing the policies from the user. Access the Security credentials tab. Scroll down to Access keys, click Actions → Delete to delete the access key. After deleting the access key, scroll to the top of the page → Click Delete to delete the IAM User. During the deletion process, click Deactivate access key if prompted. In the confirmation window, enter confirm → Click Delete user. After deleting the user, in the left navigation bar, select Policies. Find the policy AIInvoiceScannerFullPolicy → Click Delete. Re-enter the policy name to confirm → Click Delete. Repeat the above steps to delete the policy AmplifyAdminPolicy. Re-enter the policy name to confirm → Click Delete. ℹ️ To be careful, please check the services related to the project again to avoid incurring costs later!\n"
},
{
	"uri": "/2-environmentsetup/2.6-requestnovaproaccess/",
	"title": "Enable Nova Pro",
	"tags": [],
	"description": "",
	"content": "Overview In this step, you will enable the Nova Pro model on Amazon Bedrock for use in the Serverless Invoices Scanner project. This is one of Amazon\u0026rsquo;s powerful language models, suitable for tasks such as extracting, analyzing, and classifying information from invoices.\nYou only need to activate the model once per region. For this project, make sure you are operating in us-east-1 (N. Virginia) to stay in sync with Lambda, S3, and other services.\nStep 1: Access Amazon Bedrock Console Sign in to the AWS Console, search for Bedrock, then select Amazon Bedrock. In the Amazon Bedrock interface, on the left navigation panel, choose Model access. Step 2: Enable the Nova Pro model In the Base models section, scroll to find the row named Nova Pro.\nClick Available to request, then select Request model access.\nClick Next to continue. Click Submit to send your request for model access. Once successfully submitted, wait a few seconds to a few minutes. The model status will change to Access granted. Completion You have successfully enabled the Nova Pro model on Amazon Bedrock. This model is now ready to be used in the Lambda Function for processing invoice data in the Serverless Invoices Scanner system.\n"
},
{
	"uri": "/6-deployingfrontend/",
	"title": "Frontend Deployment",
	"tags": [],
	"description": "",
	"content": "Requirements Ensure you have downloaded Visual Studio Code. If not, download it from the following link: https://code.visualstudio.com/download. Step 1: Download the Source Code Click Download the Source Code. Extract the downloaded zip file. Step 2: Update API Endpoint Open Visual Studio Code. Open the .env file and replace the API endpoint values with the corresponding API IDs from API Gateway: REACT_APP_API_UPLOAD_URL : Use the API ID of PostInvoiceAPI (AWS API Gateway). REACT_APP_API_INVOICE_URL : Use the API ID of GetInvoiceAPI (AWS API Gateway). REACT_APP_API_UPDATE_TAGS_URL : Use the API ID of GetInvoiceAPI (AWS API Gateway). REACT_APP_API_UPDATE_STARRED_URL : Use the API ID of GetInvoiceAPI (AWS API Gateway). Step 3: Configure Amplify Open Terminal by pressing Ctrl + ~.\nNavigate to the project\u0026rsquo;s root directory using:\ncd \u0026lt;folder_name\u0026gt; Run the following command to install dependencies: npm install Run the following command to install AWS Amplify CLI: npm install -g @aws-amplify/cli After installation, verify that AWS Amplify CLI is installed successfully by running: amplify -v Use the following command to configure Amplify: amplify configure ⚠️ Note: After running the amplify configure command, a new browser tab will open. You can close the tab and return to Visual Studio Code to continue the configuration.\nIn the Amplify configuration, proceed as follows:\nRegion: Select us-east-1. Access Key ID: Enter the access key of the IAM User you created. Secret Access Key: Enter the secret key of the IAM User you created. Profile Name: Select default. Run the following command to initialize Amplify: amplify init Configure the initialization as follows:\n? Do you want to use an existing environment: Select No. ? Enter a name for the environment: dev. ? Select the authentication method you want to use: AWS access keys. ? accessKeyId: Enter the access key of the IAM User you created. ? secretAccessKey: Enter the secret key of the IAM User you created. ? region: us-east-1. Step 4: Configure Cognito Run the following command to add Auth using AWS Cognito: amplify add auth Configure Auth as follows:\nDo you want to use the default authentication and security configuration?: Default configuration. How do you want users to be able to sign in?: Email. Do you want to configure advanced settings?: No, I am done. Then deploy the changes: amplify push Step 5: Run the Application Start the application by running: npm start Test the following functionalities:\nUpload an invoice file. View invoice details. View all invoices. Search invoices by ID or customer name. Export to Excel. Filter by date. Sort by total amount. Sort by invoice date. Drag-and-drop for invoice upload. View invoice tags. Add invoice tags. Edit invoice tags. Filter by tags. Mark important invoices. "
},
{
	"uri": "/5-testwithpostman/5.6-testupdatetags/",
	"title": "Testing Invoice Category Update",
	"tags": [],
	"description": "",
	"content": "Step 1: Create Request In the InvoiceGetAPI-Tests Collection, click the \u0026quot;+\u0026quot; button to create a new request. Name the request: Update Invoice Tags. Select the PATCH method. Go to API Gateway and select the API: GetInvoiceAPI.\nNavigate to the Stages section.\nClick the \u0026quot;+\u0026quot; button to reveal the /invoice/tags/{id} endpoint path as shown below:\nSelect the PATCH method and copy the Invoke URL. Paste the Invoke URL into Postman as follows: Replace {id} in the API endpoint with an actual Invoice ID from DynamoDB: https://x4uqolxky6.execute-api.us-east-1.amazonaws.com/dev/invoice/tags/\u0026lt;InvoiceId_from_DynamoDB\u0026gt; Go to the Body tab → Select raw → Choose JSON. Paste the following JSON code into Postman to update invoice categories: { \u0026#34;tags\u0026#34;: [\u0026#34;VIP\u0026#34;, \u0026#34;Urgent\u0026#34;] } Click the Send button to view results. The response will appear as follows: Check the Tags field in DynamoDB to verify the update. "
},
{
	"uri": "/7-cleanup/",
	"title": "Cleaning Up Resources",
	"tags": [],
	"description": "",
	"content": "Overview In this section, you will delete and release all AWS resources that were created during the deployment of the Serverless Invoices Scanner system. Cleanup helps avoid unexpected costs and ensures that your AWS environment stays clean and optimized. Operations include deleting S3 buckets, DynamoDB tables, Lambda functions, API Gateway, Amplify service, Cognito, and other related resources.\nContent Remove API Gateway Remove Lambda Remove DynamoDB Remove S3 Bucket Remove CloudWatch Alarms Remove IAM User "
},
{
	"uri": "/5-testwithpostman/5.7-testgetinvoicebyname/",
	"title": "Testing Invoice Retrieval by Customer Name",
	"tags": [],
	"description": "",
	"content": "Step 1: Create Request In the InvoiceGetAPI-Tests Collection, click the \u0026quot;+\u0026quot; button to create a new request. Name the request: Get Invoices By Name. Select the GET method. Go to API Gateway and select the API: GetInvoiceAPI.\nNavigate to the Stages section.\nClick the \u0026quot;+\u0026quot; button to reveal the /invoice endpoint path as shown below:\nSelect the GET method and copy the Invoke URL. Paste the Invoke URL into Postman as follows: Append the following query parameter to the API endpoint: ?name=\u0026lt;customer_name\u0026gt; Enter the customer name you want to search for in the invoices. Click the Send button to view results. The response will appear as follows: "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]